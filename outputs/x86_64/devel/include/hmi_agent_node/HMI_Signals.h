// Generated by gencpp from file hmi_agent_node/HMI_Signals.msg
// DO NOT EDIT!


#ifndef HMI_AGENT_NODE_MESSAGE_HMI_SIGNALS_H
#define HMI_AGENT_NODE_MESSAGE_HMI_SIGNALS_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace hmi_agent_node
{
template <class ContainerAllocator>
struct HMI_Signals_
{
  typedef HMI_Signals_<ContainerAllocator> Type;

  HMI_Signals_()
    : drivetrain_fwd_back(0.0)
    , drivetrain_left_right(0.0)
    , drivetrain_swerve_percent_fwd_vel(0.0)
    , drivetrain_swerve_direction(0.0)
    , drivetrain_swerve_percent_angular_rot(0.0)
    , drivetrain_quickturn(false)
    , drivetrain_brake(false)
    , turret_aim_degrees(0.0)
    , turret_speed_rpm(0.0)
    , turret_hood_degrees(0.0)
    , turret_manual(false)
    , shoot_turret(false)
    , shoot_3ball(false)
    , intake_rollers(false)
    , retract_intake(false)
    , manual_intake(false)
    , manual_outake_back(false)
    , manual_outake_front(false)
    , intake_do_not_eject(false)
    , stop_climber(false)
    , deploy_hooks(false)
    , begin_climb(false)
    , retract_hooks(false)
    , forced_reset_retract_hooks(false)
    , allow_shoot(false)
    , increase_offset(false)
    , decrease_offset(false)
    , angle_increase_offset(false)
    , angle_decrease_offset(false)
    , climber_retry_last_stage(false)  {
    }
  HMI_Signals_(const ContainerAllocator& _alloc)
    : drivetrain_fwd_back(0.0)
    , drivetrain_left_right(0.0)
    , drivetrain_swerve_percent_fwd_vel(0.0)
    , drivetrain_swerve_direction(0.0)
    , drivetrain_swerve_percent_angular_rot(0.0)
    , drivetrain_quickturn(false)
    , drivetrain_brake(false)
    , turret_aim_degrees(0.0)
    , turret_speed_rpm(0.0)
    , turret_hood_degrees(0.0)
    , turret_manual(false)
    , shoot_turret(false)
    , shoot_3ball(false)
    , intake_rollers(false)
    , retract_intake(false)
    , manual_intake(false)
    , manual_outake_back(false)
    , manual_outake_front(false)
    , intake_do_not_eject(false)
    , stop_climber(false)
    , deploy_hooks(false)
    , begin_climb(false)
    , retract_hooks(false)
    , forced_reset_retract_hooks(false)
    , allow_shoot(false)
    , increase_offset(false)
    , decrease_offset(false)
    , angle_increase_offset(false)
    , angle_decrease_offset(false)
    , climber_retry_last_stage(false)  {
  (void)_alloc;
    }



   typedef double _drivetrain_fwd_back_type;
  _drivetrain_fwd_back_type drivetrain_fwd_back;

   typedef double _drivetrain_left_right_type;
  _drivetrain_left_right_type drivetrain_left_right;

   typedef double _drivetrain_swerve_percent_fwd_vel_type;
  _drivetrain_swerve_percent_fwd_vel_type drivetrain_swerve_percent_fwd_vel;

   typedef double _drivetrain_swerve_direction_type;
  _drivetrain_swerve_direction_type drivetrain_swerve_direction;

   typedef double _drivetrain_swerve_percent_angular_rot_type;
  _drivetrain_swerve_percent_angular_rot_type drivetrain_swerve_percent_angular_rot;

   typedef uint8_t _drivetrain_quickturn_type;
  _drivetrain_quickturn_type drivetrain_quickturn;

   typedef uint8_t _drivetrain_brake_type;
  _drivetrain_brake_type drivetrain_brake;

   typedef double _turret_aim_degrees_type;
  _turret_aim_degrees_type turret_aim_degrees;

   typedef double _turret_speed_rpm_type;
  _turret_speed_rpm_type turret_speed_rpm;

   typedef double _turret_hood_degrees_type;
  _turret_hood_degrees_type turret_hood_degrees;

   typedef uint8_t _turret_manual_type;
  _turret_manual_type turret_manual;

   typedef uint8_t _shoot_turret_type;
  _shoot_turret_type shoot_turret;

   typedef uint8_t _shoot_3ball_type;
  _shoot_3ball_type shoot_3ball;

   typedef uint8_t _intake_rollers_type;
  _intake_rollers_type intake_rollers;

   typedef uint8_t _retract_intake_type;
  _retract_intake_type retract_intake;

   typedef uint8_t _manual_intake_type;
  _manual_intake_type manual_intake;

   typedef uint8_t _manual_outake_back_type;
  _manual_outake_back_type manual_outake_back;

   typedef uint8_t _manual_outake_front_type;
  _manual_outake_front_type manual_outake_front;

   typedef uint8_t _intake_do_not_eject_type;
  _intake_do_not_eject_type intake_do_not_eject;

   typedef uint8_t _stop_climber_type;
  _stop_climber_type stop_climber;

   typedef uint8_t _deploy_hooks_type;
  _deploy_hooks_type deploy_hooks;

   typedef uint8_t _begin_climb_type;
  _begin_climb_type begin_climb;

   typedef uint8_t _retract_hooks_type;
  _retract_hooks_type retract_hooks;

   typedef uint8_t _forced_reset_retract_hooks_type;
  _forced_reset_retract_hooks_type forced_reset_retract_hooks;

   typedef uint8_t _allow_shoot_type;
  _allow_shoot_type allow_shoot;

   typedef uint8_t _increase_offset_type;
  _increase_offset_type increase_offset;

   typedef uint8_t _decrease_offset_type;
  _decrease_offset_type decrease_offset;

   typedef uint8_t _angle_increase_offset_type;
  _angle_increase_offset_type angle_increase_offset;

   typedef uint8_t _angle_decrease_offset_type;
  _angle_decrease_offset_type angle_decrease_offset;

   typedef uint8_t _climber_retry_last_stage_type;
  _climber_retry_last_stage_type climber_retry_last_stage;





  typedef boost::shared_ptr< ::hmi_agent_node::HMI_Signals_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::hmi_agent_node::HMI_Signals_<ContainerAllocator> const> ConstPtr;

}; // struct HMI_Signals_

typedef ::hmi_agent_node::HMI_Signals_<std::allocator<void> > HMI_Signals;

typedef boost::shared_ptr< ::hmi_agent_node::HMI_Signals > HMI_SignalsPtr;
typedef boost::shared_ptr< ::hmi_agent_node::HMI_Signals const> HMI_SignalsConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::hmi_agent_node::HMI_Signals_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::hmi_agent_node::HMI_Signals_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::hmi_agent_node::HMI_Signals_<ContainerAllocator1> & lhs, const ::hmi_agent_node::HMI_Signals_<ContainerAllocator2> & rhs)
{
  return lhs.drivetrain_fwd_back == rhs.drivetrain_fwd_back &&
    lhs.drivetrain_left_right == rhs.drivetrain_left_right &&
    lhs.drivetrain_swerve_percent_fwd_vel == rhs.drivetrain_swerve_percent_fwd_vel &&
    lhs.drivetrain_swerve_direction == rhs.drivetrain_swerve_direction &&
    lhs.drivetrain_swerve_percent_angular_rot == rhs.drivetrain_swerve_percent_angular_rot &&
    lhs.drivetrain_quickturn == rhs.drivetrain_quickturn &&
    lhs.drivetrain_brake == rhs.drivetrain_brake &&
    lhs.turret_aim_degrees == rhs.turret_aim_degrees &&
    lhs.turret_speed_rpm == rhs.turret_speed_rpm &&
    lhs.turret_hood_degrees == rhs.turret_hood_degrees &&
    lhs.turret_manual == rhs.turret_manual &&
    lhs.shoot_turret == rhs.shoot_turret &&
    lhs.shoot_3ball == rhs.shoot_3ball &&
    lhs.intake_rollers == rhs.intake_rollers &&
    lhs.retract_intake == rhs.retract_intake &&
    lhs.manual_intake == rhs.manual_intake &&
    lhs.manual_outake_back == rhs.manual_outake_back &&
    lhs.manual_outake_front == rhs.manual_outake_front &&
    lhs.intake_do_not_eject == rhs.intake_do_not_eject &&
    lhs.stop_climber == rhs.stop_climber &&
    lhs.deploy_hooks == rhs.deploy_hooks &&
    lhs.begin_climb == rhs.begin_climb &&
    lhs.retract_hooks == rhs.retract_hooks &&
    lhs.forced_reset_retract_hooks == rhs.forced_reset_retract_hooks &&
    lhs.allow_shoot == rhs.allow_shoot &&
    lhs.increase_offset == rhs.increase_offset &&
    lhs.decrease_offset == rhs.decrease_offset &&
    lhs.angle_increase_offset == rhs.angle_increase_offset &&
    lhs.angle_decrease_offset == rhs.angle_decrease_offset &&
    lhs.climber_retry_last_stage == rhs.climber_retry_last_stage;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::hmi_agent_node::HMI_Signals_<ContainerAllocator1> & lhs, const ::hmi_agent_node::HMI_Signals_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace hmi_agent_node

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::hmi_agent_node::HMI_Signals_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::hmi_agent_node::HMI_Signals_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::hmi_agent_node::HMI_Signals_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::hmi_agent_node::HMI_Signals_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::hmi_agent_node::HMI_Signals_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::hmi_agent_node::HMI_Signals_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::hmi_agent_node::HMI_Signals_<ContainerAllocator> >
{
  static const char* value()
  {
    return "0ae9d29f2f101d9821189fb63db0942f";
  }

  static const char* value(const ::hmi_agent_node::HMI_Signals_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x0ae9d29f2f101d98ULL;
  static const uint64_t static_value2 = 0x21189fb63db0942fULL;
};

template<class ContainerAllocator>
struct DataType< ::hmi_agent_node::HMI_Signals_<ContainerAllocator> >
{
  static const char* value()
  {
    return "hmi_agent_node/HMI_Signals";
  }

  static const char* value(const ::hmi_agent_node::HMI_Signals_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::hmi_agent_node::HMI_Signals_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float64 drivetrain_fwd_back\n"
"float64 drivetrain_left_right\n"
"float64 drivetrain_swerve_percent_fwd_vel\n"
"float64 drivetrain_swerve_direction\n"
"float64 drivetrain_swerve_percent_angular_rot\n"
"bool drivetrain_quickturn\n"
"bool drivetrain_brake\n"
"float64 turret_aim_degrees\n"
"float64 turret_speed_rpm\n"
"float64 turret_hood_degrees\n"
"bool turret_manual\n"
"bool shoot_turret\n"
"bool shoot_3ball\n"
"bool intake_rollers\n"
"bool retract_intake\n"
"bool manual_intake\n"
"bool manual_outake_back\n"
"bool manual_outake_front\n"
"bool intake_do_not_eject\n"
"bool stop_climber\n"
"bool deploy_hooks\n"
"bool begin_climb\n"
"bool retract_hooks\n"
"bool forced_reset_retract_hooks\n"
"bool allow_shoot\n"
"bool increase_offset\n"
"bool decrease_offset\n"
"bool angle_increase_offset\n"
"bool angle_decrease_offset\n"
"bool climber_retry_last_stage\n"
;
  }

  static const char* value(const ::hmi_agent_node::HMI_Signals_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::hmi_agent_node::HMI_Signals_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.drivetrain_fwd_back);
      stream.next(m.drivetrain_left_right);
      stream.next(m.drivetrain_swerve_percent_fwd_vel);
      stream.next(m.drivetrain_swerve_direction);
      stream.next(m.drivetrain_swerve_percent_angular_rot);
      stream.next(m.drivetrain_quickturn);
      stream.next(m.drivetrain_brake);
      stream.next(m.turret_aim_degrees);
      stream.next(m.turret_speed_rpm);
      stream.next(m.turret_hood_degrees);
      stream.next(m.turret_manual);
      stream.next(m.shoot_turret);
      stream.next(m.shoot_3ball);
      stream.next(m.intake_rollers);
      stream.next(m.retract_intake);
      stream.next(m.manual_intake);
      stream.next(m.manual_outake_back);
      stream.next(m.manual_outake_front);
      stream.next(m.intake_do_not_eject);
      stream.next(m.stop_climber);
      stream.next(m.deploy_hooks);
      stream.next(m.begin_climb);
      stream.next(m.retract_hooks);
      stream.next(m.forced_reset_retract_hooks);
      stream.next(m.allow_shoot);
      stream.next(m.increase_offset);
      stream.next(m.decrease_offset);
      stream.next(m.angle_increase_offset);
      stream.next(m.angle_decrease_offset);
      stream.next(m.climber_retry_last_stage);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct HMI_Signals_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::hmi_agent_node::HMI_Signals_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::hmi_agent_node::HMI_Signals_<ContainerAllocator>& v)
  {
    s << indent << "drivetrain_fwd_back: ";
    Printer<double>::stream(s, indent + "  ", v.drivetrain_fwd_back);
    s << indent << "drivetrain_left_right: ";
    Printer<double>::stream(s, indent + "  ", v.drivetrain_left_right);
    s << indent << "drivetrain_swerve_percent_fwd_vel: ";
    Printer<double>::stream(s, indent + "  ", v.drivetrain_swerve_percent_fwd_vel);
    s << indent << "drivetrain_swerve_direction: ";
    Printer<double>::stream(s, indent + "  ", v.drivetrain_swerve_direction);
    s << indent << "drivetrain_swerve_percent_angular_rot: ";
    Printer<double>::stream(s, indent + "  ", v.drivetrain_swerve_percent_angular_rot);
    s << indent << "drivetrain_quickturn: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.drivetrain_quickturn);
    s << indent << "drivetrain_brake: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.drivetrain_brake);
    s << indent << "turret_aim_degrees: ";
    Printer<double>::stream(s, indent + "  ", v.turret_aim_degrees);
    s << indent << "turret_speed_rpm: ";
    Printer<double>::stream(s, indent + "  ", v.turret_speed_rpm);
    s << indent << "turret_hood_degrees: ";
    Printer<double>::stream(s, indent + "  ", v.turret_hood_degrees);
    s << indent << "turret_manual: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.turret_manual);
    s << indent << "shoot_turret: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.shoot_turret);
    s << indent << "shoot_3ball: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.shoot_3ball);
    s << indent << "intake_rollers: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.intake_rollers);
    s << indent << "retract_intake: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.retract_intake);
    s << indent << "manual_intake: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.manual_intake);
    s << indent << "manual_outake_back: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.manual_outake_back);
    s << indent << "manual_outake_front: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.manual_outake_front);
    s << indent << "intake_do_not_eject: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.intake_do_not_eject);
    s << indent << "stop_climber: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.stop_climber);
    s << indent << "deploy_hooks: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.deploy_hooks);
    s << indent << "begin_climb: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.begin_climb);
    s << indent << "retract_hooks: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.retract_hooks);
    s << indent << "forced_reset_retract_hooks: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.forced_reset_retract_hooks);
    s << indent << "allow_shoot: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.allow_shoot);
    s << indent << "increase_offset: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.increase_offset);
    s << indent << "decrease_offset: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.decrease_offset);
    s << indent << "angle_increase_offset: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.angle_increase_offset);
    s << indent << "angle_decrease_offset: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.angle_decrease_offset);
    s << indent << "climber_retry_last_stage: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.climber_retry_last_stage);
  }
};

} // namespace message_operations
} // namespace ros

#endif // HMI_AGENT_NODE_MESSAGE_HMI_SIGNALS_H
