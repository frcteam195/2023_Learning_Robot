// Generated by gencpp from file rio_control_node/Motor_Config.msg
// DO NOT EDIT!


#ifndef RIO_CONTROL_NODE_MESSAGE_MOTOR_CONFIG_H
#define RIO_CONTROL_NODE_MESSAGE_MOTOR_CONFIG_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <rio_control_node/Current_Limit_Configuration.h>
#include <rio_control_node/Current_Limit_Configuration.h>

namespace rio_control_node
{
template <class ContainerAllocator>
struct Motor_Config_
{
  typedef Motor_Config_<ContainerAllocator> Type;

  Motor_Config_()
    : id(0)
    , controller_type(0)
    , controller_mode(0)
    , kP(0.0)
    , kI(0.0)
    , kD(0.0)
    , kF(0.0)
    , iZone(0.0)
    , max_i_accum(0.0)
    , allowed_closed_loop_error(0.0)
    , max_closed_loop_peak_output(0.0)
    , motion_cruise_velocity(0.0)
    , motion_acceleration(0.0)
    , motion_s_curve_strength(0)
    , forward_soft_limit(0.0)
    , forward_soft_limit_enable(false)
    , reverse_soft_limit(0.0)
    , reverse_soft_limit_enable(false)
    , feedback_sensor_coefficient(0.0)
    , voltage_compensation_saturation(0.0)
    , voltage_compensation_enabled(false)
    , invert_type(0)
    , sensor_phase_inverted(false)
    , neutral_mode(0)
    , open_loop_ramp(0.0)
    , closed_loop_ramp(0.0)
    , supply_current_limit_config()
    , stator_current_limit_config()
    , forward_limit_switch_source(0)
    , forward_limit_switch_normal(0)
    , reverse_limit_switch_source(0)
    , reverse_limit_switch_normal(0)
    , peak_output_forward(0.0)
    , peak_output_reverse(0.0)  {
    }
  Motor_Config_(const ContainerAllocator& _alloc)
    : id(0)
    , controller_type(0)
    , controller_mode(0)
    , kP(0.0)
    , kI(0.0)
    , kD(0.0)
    , kF(0.0)
    , iZone(0.0)
    , max_i_accum(0.0)
    , allowed_closed_loop_error(0.0)
    , max_closed_loop_peak_output(0.0)
    , motion_cruise_velocity(0.0)
    , motion_acceleration(0.0)
    , motion_s_curve_strength(0)
    , forward_soft_limit(0.0)
    , forward_soft_limit_enable(false)
    , reverse_soft_limit(0.0)
    , reverse_soft_limit_enable(false)
    , feedback_sensor_coefficient(0.0)
    , voltage_compensation_saturation(0.0)
    , voltage_compensation_enabled(false)
    , invert_type(0)
    , sensor_phase_inverted(false)
    , neutral_mode(0)
    , open_loop_ramp(0.0)
    , closed_loop_ramp(0.0)
    , supply_current_limit_config(_alloc)
    , stator_current_limit_config(_alloc)
    , forward_limit_switch_source(0)
    , forward_limit_switch_normal(0)
    , reverse_limit_switch_source(0)
    , reverse_limit_switch_normal(0)
    , peak_output_forward(0.0)
    , peak_output_reverse(0.0)  {
  (void)_alloc;
    }



   typedef int32_t _id_type;
  _id_type id;

   typedef uint8_t _controller_type_type;
  _controller_type_type controller_type;

   typedef uint8_t _controller_mode_type;
  _controller_mode_type controller_mode;

   typedef double _kP_type;
  _kP_type kP;

   typedef double _kI_type;
  _kI_type kI;

   typedef double _kD_type;
  _kD_type kD;

   typedef double _kF_type;
  _kF_type kF;

   typedef double _iZone_type;
  _iZone_type iZone;

   typedef double _max_i_accum_type;
  _max_i_accum_type max_i_accum;

   typedef double _allowed_closed_loop_error_type;
  _allowed_closed_loop_error_type allowed_closed_loop_error;

   typedef double _max_closed_loop_peak_output_type;
  _max_closed_loop_peak_output_type max_closed_loop_peak_output;

   typedef double _motion_cruise_velocity_type;
  _motion_cruise_velocity_type motion_cruise_velocity;

   typedef double _motion_acceleration_type;
  _motion_acceleration_type motion_acceleration;

   typedef int32_t _motion_s_curve_strength_type;
  _motion_s_curve_strength_type motion_s_curve_strength;

   typedef double _forward_soft_limit_type;
  _forward_soft_limit_type forward_soft_limit;

   typedef uint8_t _forward_soft_limit_enable_type;
  _forward_soft_limit_enable_type forward_soft_limit_enable;

   typedef double _reverse_soft_limit_type;
  _reverse_soft_limit_type reverse_soft_limit;

   typedef uint8_t _reverse_soft_limit_enable_type;
  _reverse_soft_limit_enable_type reverse_soft_limit_enable;

   typedef double _feedback_sensor_coefficient_type;
  _feedback_sensor_coefficient_type feedback_sensor_coefficient;

   typedef double _voltage_compensation_saturation_type;
  _voltage_compensation_saturation_type voltage_compensation_saturation;

   typedef uint8_t _voltage_compensation_enabled_type;
  _voltage_compensation_enabled_type voltage_compensation_enabled;

   typedef uint8_t _invert_type_type;
  _invert_type_type invert_type;

   typedef uint8_t _sensor_phase_inverted_type;
  _sensor_phase_inverted_type sensor_phase_inverted;

   typedef uint8_t _neutral_mode_type;
  _neutral_mode_type neutral_mode;

   typedef double _open_loop_ramp_type;
  _open_loop_ramp_type open_loop_ramp;

   typedef double _closed_loop_ramp_type;
  _closed_loop_ramp_type closed_loop_ramp;

   typedef  ::rio_control_node::Current_Limit_Configuration_<ContainerAllocator>  _supply_current_limit_config_type;
  _supply_current_limit_config_type supply_current_limit_config;

   typedef  ::rio_control_node::Current_Limit_Configuration_<ContainerAllocator>  _stator_current_limit_config_type;
  _stator_current_limit_config_type stator_current_limit_config;

   typedef int8_t _forward_limit_switch_source_type;
  _forward_limit_switch_source_type forward_limit_switch_source;

   typedef int8_t _forward_limit_switch_normal_type;
  _forward_limit_switch_normal_type forward_limit_switch_normal;

   typedef int8_t _reverse_limit_switch_source_type;
  _reverse_limit_switch_source_type reverse_limit_switch_source;

   typedef int8_t _reverse_limit_switch_normal_type;
  _reverse_limit_switch_normal_type reverse_limit_switch_normal;

   typedef double _peak_output_forward_type;
  _peak_output_forward_type peak_output_forward;

   typedef double _peak_output_reverse_type;
  _peak_output_reverse_type peak_output_reverse;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(TALON_FX)
  #undef TALON_FX
#endif
#if defined(_WIN32) && defined(TALON_SRX)
  #undef TALON_SRX
#endif
#if defined(_WIN32) && defined(MASTER)
  #undef MASTER
#endif
#if defined(_WIN32) && defined(FAST_MASTER)
  #undef FAST_MASTER
#endif
#if defined(_WIN32) && defined(FOLLOWER)
  #undef FOLLOWER
#endif
#if defined(_WIN32) && defined(NONE)
  #undef NONE
#endif
#if defined(_WIN32) && defined(INVERT_MOTOR_OUTPUT)
  #undef INVERT_MOTOR_OUTPUT
#endif
#if defined(_WIN32) && defined(FOLLOW_MASTER)
  #undef FOLLOW_MASTER
#endif
#if defined(_WIN32) && defined(OPPOSE_MASTER)
  #undef OPPOSE_MASTER
#endif
#if defined(_WIN32) && defined(LIMITSWITCHSOURCE_FEEDBACKCONNECTOR)
  #undef LIMITSWITCHSOURCE_FEEDBACKCONNECTOR
#endif
#if defined(_WIN32) && defined(LIMITSWITCHSOURCE_REMOTETALON)
  #undef LIMITSWITCHSOURCE_REMOTETALON
#endif
#if defined(_WIN32) && defined(LIMITSWITCHSOURCE_REMOTETALONSRX)
  #undef LIMITSWITCHSOURCE_REMOTETALONSRX
#endif
#if defined(_WIN32) && defined(LIMITSWITCHSOURCE_REMOTECANIFIER)
  #undef LIMITSWITCHSOURCE_REMOTECANIFIER
#endif
#if defined(_WIN32) && defined(LIMITSWITCHSOURCE_DEACTIVATED)
  #undef LIMITSWITCHSOURCE_DEACTIVATED
#endif
#if defined(_WIN32) && defined(LIMITSWITCHNORMAL_NORMALLYOPEN)
  #undef LIMITSWITCHNORMAL_NORMALLYOPEN
#endif
#if defined(_WIN32) && defined(LIMITSWITCHNORMAL_NORMALLYCLOSED)
  #undef LIMITSWITCHNORMAL_NORMALLYCLOSED
#endif
#if defined(_WIN32) && defined(LIMITSWITCHNORMAL_DISABLED)
  #undef LIMITSWITCHNORMAL_DISABLED
#endif
#if defined(_WIN32) && defined(EEPROM_SETTING)
  #undef EEPROM_SETTING
#endif
#if defined(_WIN32) && defined(COAST)
  #undef COAST
#endif
#if defined(_WIN32) && defined(BRAKE)
  #undef BRAKE
#endif

  enum {
    TALON_FX = 0,
    TALON_SRX = 1,
    MASTER = 0,
    FAST_MASTER = 1,
    FOLLOWER = 2,
    NONE = 0,
    INVERT_MOTOR_OUTPUT = 1,
    FOLLOW_MASTER = 2,
    OPPOSE_MASTER = 3,
    LIMITSWITCHSOURCE_FEEDBACKCONNECTOR = 0,
    LIMITSWITCHSOURCE_REMOTETALON = 1,
    LIMITSWITCHSOURCE_REMOTETALONSRX = 1,
    LIMITSWITCHSOURCE_REMOTECANIFIER = 2,
    LIMITSWITCHSOURCE_DEACTIVATED = 3,
    LIMITSWITCHNORMAL_NORMALLYOPEN = 0,
    LIMITSWITCHNORMAL_NORMALLYCLOSED = 1,
    LIMITSWITCHNORMAL_DISABLED = 2,
    EEPROM_SETTING = 0,
    COAST = 1,
    BRAKE = 2,
  };


  typedef boost::shared_ptr< ::rio_control_node::Motor_Config_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::rio_control_node::Motor_Config_<ContainerAllocator> const> ConstPtr;

}; // struct Motor_Config_

typedef ::rio_control_node::Motor_Config_<std::allocator<void> > Motor_Config;

typedef boost::shared_ptr< ::rio_control_node::Motor_Config > Motor_ConfigPtr;
typedef boost::shared_ptr< ::rio_control_node::Motor_Config const> Motor_ConfigConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::rio_control_node::Motor_Config_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::rio_control_node::Motor_Config_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::rio_control_node::Motor_Config_<ContainerAllocator1> & lhs, const ::rio_control_node::Motor_Config_<ContainerAllocator2> & rhs)
{
  return lhs.id == rhs.id &&
    lhs.controller_type == rhs.controller_type &&
    lhs.controller_mode == rhs.controller_mode &&
    lhs.kP == rhs.kP &&
    lhs.kI == rhs.kI &&
    lhs.kD == rhs.kD &&
    lhs.kF == rhs.kF &&
    lhs.iZone == rhs.iZone &&
    lhs.max_i_accum == rhs.max_i_accum &&
    lhs.allowed_closed_loop_error == rhs.allowed_closed_loop_error &&
    lhs.max_closed_loop_peak_output == rhs.max_closed_loop_peak_output &&
    lhs.motion_cruise_velocity == rhs.motion_cruise_velocity &&
    lhs.motion_acceleration == rhs.motion_acceleration &&
    lhs.motion_s_curve_strength == rhs.motion_s_curve_strength &&
    lhs.forward_soft_limit == rhs.forward_soft_limit &&
    lhs.forward_soft_limit_enable == rhs.forward_soft_limit_enable &&
    lhs.reverse_soft_limit == rhs.reverse_soft_limit &&
    lhs.reverse_soft_limit_enable == rhs.reverse_soft_limit_enable &&
    lhs.feedback_sensor_coefficient == rhs.feedback_sensor_coefficient &&
    lhs.voltage_compensation_saturation == rhs.voltage_compensation_saturation &&
    lhs.voltage_compensation_enabled == rhs.voltage_compensation_enabled &&
    lhs.invert_type == rhs.invert_type &&
    lhs.sensor_phase_inverted == rhs.sensor_phase_inverted &&
    lhs.neutral_mode == rhs.neutral_mode &&
    lhs.open_loop_ramp == rhs.open_loop_ramp &&
    lhs.closed_loop_ramp == rhs.closed_loop_ramp &&
    lhs.supply_current_limit_config == rhs.supply_current_limit_config &&
    lhs.stator_current_limit_config == rhs.stator_current_limit_config &&
    lhs.forward_limit_switch_source == rhs.forward_limit_switch_source &&
    lhs.forward_limit_switch_normal == rhs.forward_limit_switch_normal &&
    lhs.reverse_limit_switch_source == rhs.reverse_limit_switch_source &&
    lhs.reverse_limit_switch_normal == rhs.reverse_limit_switch_normal &&
    lhs.peak_output_forward == rhs.peak_output_forward &&
    lhs.peak_output_reverse == rhs.peak_output_reverse;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::rio_control_node::Motor_Config_<ContainerAllocator1> & lhs, const ::rio_control_node::Motor_Config_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace rio_control_node

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::rio_control_node::Motor_Config_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::rio_control_node::Motor_Config_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::rio_control_node::Motor_Config_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::rio_control_node::Motor_Config_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::rio_control_node::Motor_Config_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::rio_control_node::Motor_Config_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::rio_control_node::Motor_Config_<ContainerAllocator> >
{
  static const char* value()
  {
    return "29280c49139b59cecab3e5c991766c20";
  }

  static const char* value(const ::rio_control_node::Motor_Config_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x29280c49139b59ceULL;
  static const uint64_t static_value2 = 0xcab3e5c991766c20ULL;
};

template<class ContainerAllocator>
struct DataType< ::rio_control_node::Motor_Config_<ContainerAllocator> >
{
  static const char* value()
  {
    return "rio_control_node/Motor_Config";
  }

  static const char* value(const ::rio_control_node::Motor_Config_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::rio_control_node::Motor_Config_<ContainerAllocator> >
{
  static const char* value()
  {
    return "int8 TALON_FX=0\n"
"int8 TALON_SRX=1\n"
"\n"
"int8 MASTER=0\n"
"int8 FAST_MASTER=1\n"
"int8 FOLLOWER=2\n"
"\n"
"int8 NONE=0\n"
"int8 INVERT_MOTOR_OUTPUT=1\n"
"int8 FOLLOW_MASTER=2\n"
"int8 OPPOSE_MASTER=3\n"
"\n"
"int8 LIMITSWITCHSOURCE_FEEDBACKCONNECTOR = 0\n"
"int8 LIMITSWITCHSOURCE_REMOTETALON = 1\n"
"int8 LIMITSWITCHSOURCE_REMOTETALONSRX = 1\n"
"int8 LIMITSWITCHSOURCE_REMOTECANIFIER = 2\n"
"int8 LIMITSWITCHSOURCE_DEACTIVATED = 3\n"
"\n"
"int8 LIMITSWITCHNORMAL_NORMALLYOPEN = 0\n"
"int8 LIMITSWITCHNORMAL_NORMALLYCLOSED = 1\n"
"int8 LIMITSWITCHNORMAL_DISABLED = 2\n"
"\n"
"int8 EEPROM_SETTING=0\n"
"int8 COAST=1\n"
"int8 BRAKE=2\n"
"\n"
"\n"
"int32 id\n"
"uint8 controller_type\n"
"uint8 controller_mode\n"
"float64 kP\n"
"float64 kI\n"
"float64 kD\n"
"float64 kF\n"
"float64 iZone\n"
"float64 max_i_accum\n"
"float64 allowed_closed_loop_error\n"
"float64 max_closed_loop_peak_output\n"
"float64 motion_cruise_velocity\n"
"float64 motion_acceleration\n"
"int32 motion_s_curve_strength\n"
"float64 forward_soft_limit\n"
"bool forward_soft_limit_enable\n"
"float64 reverse_soft_limit\n"
"bool reverse_soft_limit_enable\n"
"float64 feedback_sensor_coefficient\n"
"float64 voltage_compensation_saturation\n"
"bool voltage_compensation_enabled\n"
"uint8 invert_type\n"
"bool sensor_phase_inverted\n"
"uint8 neutral_mode\n"
"float64 open_loop_ramp\n"
"float64 closed_loop_ramp\n"
"Current_Limit_Configuration supply_current_limit_config\n"
"Current_Limit_Configuration stator_current_limit_config\n"
"int8 forward_limit_switch_source\n"
"int8 forward_limit_switch_normal\n"
"int8 reverse_limit_switch_source\n"
"int8 reverse_limit_switch_normal\n"
"float64 peak_output_forward\n"
"float64 peak_output_reverse\n"
"\n"
"================================================================================\n"
"MSG: rio_control_node/Current_Limit_Configuration\n"
"bool enable\n"
"float64 current_limit\n"
"float64 trigger_threshold_current\n"
"float64 trigger_threshold_time\n"
;
  }

  static const char* value(const ::rio_control_node::Motor_Config_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::rio_control_node::Motor_Config_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.id);
      stream.next(m.controller_type);
      stream.next(m.controller_mode);
      stream.next(m.kP);
      stream.next(m.kI);
      stream.next(m.kD);
      stream.next(m.kF);
      stream.next(m.iZone);
      stream.next(m.max_i_accum);
      stream.next(m.allowed_closed_loop_error);
      stream.next(m.max_closed_loop_peak_output);
      stream.next(m.motion_cruise_velocity);
      stream.next(m.motion_acceleration);
      stream.next(m.motion_s_curve_strength);
      stream.next(m.forward_soft_limit);
      stream.next(m.forward_soft_limit_enable);
      stream.next(m.reverse_soft_limit);
      stream.next(m.reverse_soft_limit_enable);
      stream.next(m.feedback_sensor_coefficient);
      stream.next(m.voltage_compensation_saturation);
      stream.next(m.voltage_compensation_enabled);
      stream.next(m.invert_type);
      stream.next(m.sensor_phase_inverted);
      stream.next(m.neutral_mode);
      stream.next(m.open_loop_ramp);
      stream.next(m.closed_loop_ramp);
      stream.next(m.supply_current_limit_config);
      stream.next(m.stator_current_limit_config);
      stream.next(m.forward_limit_switch_source);
      stream.next(m.forward_limit_switch_normal);
      stream.next(m.reverse_limit_switch_source);
      stream.next(m.reverse_limit_switch_normal);
      stream.next(m.peak_output_forward);
      stream.next(m.peak_output_reverse);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Motor_Config_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::rio_control_node::Motor_Config_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::rio_control_node::Motor_Config_<ContainerAllocator>& v)
  {
    s << indent << "id: ";
    Printer<int32_t>::stream(s, indent + "  ", v.id);
    s << indent << "controller_type: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.controller_type);
    s << indent << "controller_mode: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.controller_mode);
    s << indent << "kP: ";
    Printer<double>::stream(s, indent + "  ", v.kP);
    s << indent << "kI: ";
    Printer<double>::stream(s, indent + "  ", v.kI);
    s << indent << "kD: ";
    Printer<double>::stream(s, indent + "  ", v.kD);
    s << indent << "kF: ";
    Printer<double>::stream(s, indent + "  ", v.kF);
    s << indent << "iZone: ";
    Printer<double>::stream(s, indent + "  ", v.iZone);
    s << indent << "max_i_accum: ";
    Printer<double>::stream(s, indent + "  ", v.max_i_accum);
    s << indent << "allowed_closed_loop_error: ";
    Printer<double>::stream(s, indent + "  ", v.allowed_closed_loop_error);
    s << indent << "max_closed_loop_peak_output: ";
    Printer<double>::stream(s, indent + "  ", v.max_closed_loop_peak_output);
    s << indent << "motion_cruise_velocity: ";
    Printer<double>::stream(s, indent + "  ", v.motion_cruise_velocity);
    s << indent << "motion_acceleration: ";
    Printer<double>::stream(s, indent + "  ", v.motion_acceleration);
    s << indent << "motion_s_curve_strength: ";
    Printer<int32_t>::stream(s, indent + "  ", v.motion_s_curve_strength);
    s << indent << "forward_soft_limit: ";
    Printer<double>::stream(s, indent + "  ", v.forward_soft_limit);
    s << indent << "forward_soft_limit_enable: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.forward_soft_limit_enable);
    s << indent << "reverse_soft_limit: ";
    Printer<double>::stream(s, indent + "  ", v.reverse_soft_limit);
    s << indent << "reverse_soft_limit_enable: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.reverse_soft_limit_enable);
    s << indent << "feedback_sensor_coefficient: ";
    Printer<double>::stream(s, indent + "  ", v.feedback_sensor_coefficient);
    s << indent << "voltage_compensation_saturation: ";
    Printer<double>::stream(s, indent + "  ", v.voltage_compensation_saturation);
    s << indent << "voltage_compensation_enabled: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.voltage_compensation_enabled);
    s << indent << "invert_type: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.invert_type);
    s << indent << "sensor_phase_inverted: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.sensor_phase_inverted);
    s << indent << "neutral_mode: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.neutral_mode);
    s << indent << "open_loop_ramp: ";
    Printer<double>::stream(s, indent + "  ", v.open_loop_ramp);
    s << indent << "closed_loop_ramp: ";
    Printer<double>::stream(s, indent + "  ", v.closed_loop_ramp);
    s << indent << "supply_current_limit_config: ";
    s << std::endl;
    Printer< ::rio_control_node::Current_Limit_Configuration_<ContainerAllocator> >::stream(s, indent + "  ", v.supply_current_limit_config);
    s << indent << "stator_current_limit_config: ";
    s << std::endl;
    Printer< ::rio_control_node::Current_Limit_Configuration_<ContainerAllocator> >::stream(s, indent + "  ", v.stator_current_limit_config);
    s << indent << "forward_limit_switch_source: ";
    Printer<int8_t>::stream(s, indent + "  ", v.forward_limit_switch_source);
    s << indent << "forward_limit_switch_normal: ";
    Printer<int8_t>::stream(s, indent + "  ", v.forward_limit_switch_normal);
    s << indent << "reverse_limit_switch_source: ";
    Printer<int8_t>::stream(s, indent + "  ", v.reverse_limit_switch_source);
    s << indent << "reverse_limit_switch_normal: ";
    Printer<int8_t>::stream(s, indent + "  ", v.reverse_limit_switch_normal);
    s << indent << "peak_output_forward: ";
    Printer<double>::stream(s, indent + "  ", v.peak_output_forward);
    s << indent << "peak_output_reverse: ";
    Printer<double>::stream(s, indent + "  ", v.peak_output_reverse);
  }
};

} // namespace message_operations
} // namespace ros

#endif // RIO_CONTROL_NODE_MESSAGE_MOTOR_CONFIG_H
