# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from rio_control_node/Motor_Configuration.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import rio_control_node.msg

class Motor_Configuration(genpy.Message):
  _md5sum = "b4aa30f1c6e967c36fb4276685a52367"
  _type = "rio_control_node/Motor_Configuration"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """Motor_Config[] motors
================================================================================
MSG: rio_control_node/Motor_Config
int8 TALON_FX=0
int8 TALON_SRX=1

int8 MASTER=0
int8 FAST_MASTER=1
int8 FOLLOWER=2

int8 NONE=0
int8 INVERT_MOTOR_OUTPUT=1
int8 FOLLOW_MASTER=2
int8 OPPOSE_MASTER=3

int8 LIMITSWITCHSOURCE_FEEDBACKCONNECTOR = 0
int8 LIMITSWITCHSOURCE_REMOTETALON = 1
int8 LIMITSWITCHSOURCE_REMOTETALONSRX = 1
int8 LIMITSWITCHSOURCE_REMOTECANIFIER = 2
int8 LIMITSWITCHSOURCE_DEACTIVATED = 3

int8 LIMITSWITCHNORMAL_NORMALLYOPEN = 0
int8 LIMITSWITCHNORMAL_NORMALLYCLOSED = 1
int8 LIMITSWITCHNORMAL_DISABLED = 2

int8 EEPROM_SETTING=0
int8 COAST=1
int8 BRAKE=2


int32 id
uint8 controller_type
uint8 controller_mode
float64 kP
float64 kI
float64 kD
float64 kF
float64 iZone
float64 max_i_accum
float64 allowed_closed_loop_error
float64 max_closed_loop_peak_output
float64 motion_cruise_velocity
float64 motion_acceleration
int32 motion_s_curve_strength
float64 forward_soft_limit
bool forward_soft_limit_enable
float64 reverse_soft_limit
bool reverse_soft_limit_enable
float64 feedback_sensor_coefficient
float64 voltage_compensation_saturation
bool voltage_compensation_enabled
uint8 invert_type
bool sensor_phase_inverted
uint8 neutral_mode
float64 open_loop_ramp
float64 closed_loop_ramp
Current_Limit_Configuration supply_current_limit_config
Current_Limit_Configuration stator_current_limit_config
int8 forward_limit_switch_source
int8 forward_limit_switch_normal
int8 reverse_limit_switch_source
int8 reverse_limit_switch_normal
float64 peak_output_forward
float64 peak_output_reverse

================================================================================
MSG: rio_control_node/Current_Limit_Configuration
bool enable
float64 current_limit
float64 trigger_threshold_current
float64 trigger_threshold_time"""
  __slots__ = ['motors']
  _slot_types = ['rio_control_node/Motor_Config[]']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       motors

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(Motor_Configuration, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.motors is None:
        self.motors = []
    else:
      self.motors = []

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      length = len(self.motors)
      buff.write(_struct_I.pack(length))
      for val1 in self.motors:
        _x = val1
        buff.write(_get_struct_i2B10didBdB2d4B2d().pack(_x.id, _x.controller_type, _x.controller_mode, _x.kP, _x.kI, _x.kD, _x.kF, _x.iZone, _x.max_i_accum, _x.allowed_closed_loop_error, _x.max_closed_loop_peak_output, _x.motion_cruise_velocity, _x.motion_acceleration, _x.motion_s_curve_strength, _x.forward_soft_limit, _x.forward_soft_limit_enable, _x.reverse_soft_limit, _x.reverse_soft_limit_enable, _x.feedback_sensor_coefficient, _x.voltage_compensation_saturation, _x.voltage_compensation_enabled, _x.invert_type, _x.sensor_phase_inverted, _x.neutral_mode, _x.open_loop_ramp, _x.closed_loop_ramp))
        _v1 = val1.supply_current_limit_config
        _x = _v1
        buff.write(_get_struct_B3d().pack(_x.enable, _x.current_limit, _x.trigger_threshold_current, _x.trigger_threshold_time))
        _v2 = val1.stator_current_limit_config
        _x = _v2
        buff.write(_get_struct_B3d().pack(_x.enable, _x.current_limit, _x.trigger_threshold_current, _x.trigger_threshold_time))
        _x = val1
        buff.write(_get_struct_4b2d().pack(_x.forward_limit_switch_source, _x.forward_limit_switch_normal, _x.reverse_limit_switch_source, _x.reverse_limit_switch_normal, _x.peak_output_forward, _x.peak_output_reverse))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.motors is None:
        self.motors = None
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.motors = []
      for i in range(0, length):
        val1 = rio_control_node.msg.Motor_Config()
        _x = val1
        start = end
        end += 144
        (_x.id, _x.controller_type, _x.controller_mode, _x.kP, _x.kI, _x.kD, _x.kF, _x.iZone, _x.max_i_accum, _x.allowed_closed_loop_error, _x.max_closed_loop_peak_output, _x.motion_cruise_velocity, _x.motion_acceleration, _x.motion_s_curve_strength, _x.forward_soft_limit, _x.forward_soft_limit_enable, _x.reverse_soft_limit, _x.reverse_soft_limit_enable, _x.feedback_sensor_coefficient, _x.voltage_compensation_saturation, _x.voltage_compensation_enabled, _x.invert_type, _x.sensor_phase_inverted, _x.neutral_mode, _x.open_loop_ramp, _x.closed_loop_ramp,) = _get_struct_i2B10didBdB2d4B2d().unpack(str[start:end])
        val1.forward_soft_limit_enable = bool(val1.forward_soft_limit_enable)
        val1.reverse_soft_limit_enable = bool(val1.reverse_soft_limit_enable)
        val1.voltage_compensation_enabled = bool(val1.voltage_compensation_enabled)
        val1.sensor_phase_inverted = bool(val1.sensor_phase_inverted)
        _v3 = val1.supply_current_limit_config
        _x = _v3
        start = end
        end += 25
        (_x.enable, _x.current_limit, _x.trigger_threshold_current, _x.trigger_threshold_time,) = _get_struct_B3d().unpack(str[start:end])
        _v3.enable = bool(_v3.enable)
        _v4 = val1.stator_current_limit_config
        _x = _v4
        start = end
        end += 25
        (_x.enable, _x.current_limit, _x.trigger_threshold_current, _x.trigger_threshold_time,) = _get_struct_B3d().unpack(str[start:end])
        _v4.enable = bool(_v4.enable)
        _x = val1
        start = end
        end += 20
        (_x.forward_limit_switch_source, _x.forward_limit_switch_normal, _x.reverse_limit_switch_source, _x.reverse_limit_switch_normal, _x.peak_output_forward, _x.peak_output_reverse,) = _get_struct_4b2d().unpack(str[start:end])
        self.motors.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      length = len(self.motors)
      buff.write(_struct_I.pack(length))
      for val1 in self.motors:
        _x = val1
        buff.write(_get_struct_i2B10didBdB2d4B2d().pack(_x.id, _x.controller_type, _x.controller_mode, _x.kP, _x.kI, _x.kD, _x.kF, _x.iZone, _x.max_i_accum, _x.allowed_closed_loop_error, _x.max_closed_loop_peak_output, _x.motion_cruise_velocity, _x.motion_acceleration, _x.motion_s_curve_strength, _x.forward_soft_limit, _x.forward_soft_limit_enable, _x.reverse_soft_limit, _x.reverse_soft_limit_enable, _x.feedback_sensor_coefficient, _x.voltage_compensation_saturation, _x.voltage_compensation_enabled, _x.invert_type, _x.sensor_phase_inverted, _x.neutral_mode, _x.open_loop_ramp, _x.closed_loop_ramp))
        _v5 = val1.supply_current_limit_config
        _x = _v5
        buff.write(_get_struct_B3d().pack(_x.enable, _x.current_limit, _x.trigger_threshold_current, _x.trigger_threshold_time))
        _v6 = val1.stator_current_limit_config
        _x = _v6
        buff.write(_get_struct_B3d().pack(_x.enable, _x.current_limit, _x.trigger_threshold_current, _x.trigger_threshold_time))
        _x = val1
        buff.write(_get_struct_4b2d().pack(_x.forward_limit_switch_source, _x.forward_limit_switch_normal, _x.reverse_limit_switch_source, _x.reverse_limit_switch_normal, _x.peak_output_forward, _x.peak_output_reverse))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.motors is None:
        self.motors = None
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.motors = []
      for i in range(0, length):
        val1 = rio_control_node.msg.Motor_Config()
        _x = val1
        start = end
        end += 144
        (_x.id, _x.controller_type, _x.controller_mode, _x.kP, _x.kI, _x.kD, _x.kF, _x.iZone, _x.max_i_accum, _x.allowed_closed_loop_error, _x.max_closed_loop_peak_output, _x.motion_cruise_velocity, _x.motion_acceleration, _x.motion_s_curve_strength, _x.forward_soft_limit, _x.forward_soft_limit_enable, _x.reverse_soft_limit, _x.reverse_soft_limit_enable, _x.feedback_sensor_coefficient, _x.voltage_compensation_saturation, _x.voltage_compensation_enabled, _x.invert_type, _x.sensor_phase_inverted, _x.neutral_mode, _x.open_loop_ramp, _x.closed_loop_ramp,) = _get_struct_i2B10didBdB2d4B2d().unpack(str[start:end])
        val1.forward_soft_limit_enable = bool(val1.forward_soft_limit_enable)
        val1.reverse_soft_limit_enable = bool(val1.reverse_soft_limit_enable)
        val1.voltage_compensation_enabled = bool(val1.voltage_compensation_enabled)
        val1.sensor_phase_inverted = bool(val1.sensor_phase_inverted)
        _v7 = val1.supply_current_limit_config
        _x = _v7
        start = end
        end += 25
        (_x.enable, _x.current_limit, _x.trigger_threshold_current, _x.trigger_threshold_time,) = _get_struct_B3d().unpack(str[start:end])
        _v7.enable = bool(_v7.enable)
        _v8 = val1.stator_current_limit_config
        _x = _v8
        start = end
        end += 25
        (_x.enable, _x.current_limit, _x.trigger_threshold_current, _x.trigger_threshold_time,) = _get_struct_B3d().unpack(str[start:end])
        _v8.enable = bool(_v8.enable)
        _x = val1
        start = end
        end += 20
        (_x.forward_limit_switch_source, _x.forward_limit_switch_normal, _x.reverse_limit_switch_source, _x.reverse_limit_switch_normal, _x.peak_output_forward, _x.peak_output_reverse,) = _get_struct_4b2d().unpack(str[start:end])
        self.motors.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_4b2d = None
def _get_struct_4b2d():
    global _struct_4b2d
    if _struct_4b2d is None:
        _struct_4b2d = struct.Struct("<4b2d")
    return _struct_4b2d
_struct_B3d = None
def _get_struct_B3d():
    global _struct_B3d
    if _struct_B3d is None:
        _struct_B3d = struct.Struct("<B3d")
    return _struct_B3d
_struct_i2B10didBdB2d4B2d = None
def _get_struct_i2B10didBdB2d4B2d():
    global _struct_i2B10didBdB2d4B2d
    if _struct_i2B10didBdB2d4B2d is None:
        _struct_i2B10didBdB2d4B2d = struct.Struct("<i2B10didBdB2d4B2d")
    return _struct_i2B10didBdB2d4B2d
